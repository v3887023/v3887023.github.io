{"meta":{"title":"See!","subtitle":"What can I do.","description":null,"author":"Victor","url":"https://v3887023.github.io"},"pages":[{"title":"404 Not Found!","date":"2018-01-13T13:09:34.000Z","updated":"2018-01-13T13:33:15.116Z","comments":false,"path":"/404.html","permalink":"https://v3887023.github.io//404.html","excerpt":"","text":"页面无法显示"},{"title":"关于我","date":"2017-12-16T03:18:03.000Z","updated":"2017-12-16T03:20:47.693Z","comments":true,"path":"about/index.html","permalink":"https://v3887023.github.io/about/index.html","excerpt":"","text":"张朝兴大二学生喜欢打羽毛球"},{"title":"分类","date":"2017-12-16T03:50:56.000Z","updated":"2018-01-17T15:32:09.771Z","comments":false,"path":"categories/index.html","permalink":"https://v3887023.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-01-17T14:15:15.000Z","updated":"2018-01-17T15:32:23.203Z","comments":true,"path":"tags/index.html","permalink":"https://v3887023.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"LocalBroadcastManager 笔记","slug":"LocalBroadcastManager-笔记","date":"2019-06-03T08:59:13.000Z","updated":"2019-06-03T09:53:42.510Z","comments":true,"path":"2019/06/03/LocalBroadcastManager-笔记/","link":"","permalink":"https://v3887023.github.io/2019/06/03/LocalBroadcastManager-笔记/","excerpt":"记录学习 LocalBroadcastManager 的过程。","text":"记录学习 LocalBroadcastManager 的过程。 LocalBroadcastManager 是一个帮助注册和发送广播的一个管理类。它能够在进程内发送包含 Intent 对象的广播。比起发送全局广播，它有以下几个有点： 广播的数据不会离开当前的 App，因此无需担心会泄漏隐私数据 其他应用程序无法向当前的 App 发送广播，因此也无需担心他们会利用安全漏洞搞事情 比起发送一个全局广播遍布整个系统，本地广播更加高效。 LocalBroadcastManager 有两个私有静态内部类，即 ReceiverRecord 和 BraodcastRecord。 ReceiverRecord 是接收器的记录。12345678910111213141516private static final class ReceiverRecord &#123; final IntentFilter filter; final BroadcastReceiver receiver; boolean broadcasting; boolean dead; ReceiverRecord(IntentFilter _filter, BroadcastReceiver _receiver) &#123; filter = _filter; receiver = _receiver; &#125; @Override public String toString() &#123; ... //省略 &#125;&#125; BroadcastRecord 是广播的记录。123456789private static final class BroadcastRecord &#123; final Intent intent; final ArrayList&lt;ReceiverRecord&gt; receivers; BroadcastRecord(Intent _intent, ArrayList&lt;ReceiverRecord&gt; _receivers) &#123; intent = _intent; receivers = _receivers; &#125;&#125; LocalBroadcastManager 采用了单例模式，代码如下：1234567891011121314151617181920private final Context mAppContext;static final int MSG_EXEC_PENDING_BROADCASTS = 1;private final Handler mHandler;private static final Object mLock = new Object();private static LocalBroadcastManager mInstance;@NonNullpublic static LocalBroadcastManager getInstance(@NonNull Context context) &#123; synchronized (mLock) &#123; if (mInstance == null) &#123; mInstance = new LocalBroadcastManager(context.getApplicationContext()); &#125; return mInstance; &#125;&#125;private LocalBroadcastManager(Context context) &#123; mAppContext = context; mHandler = ... // 省略，初始化 Handler，这个后面会提到&#125; LocalBroadcastManager 的几个重要成员变量，如下：12345678// 映射：广播接收器 -&gt; 接收器记录的列表private final HashMap&lt;BroadcastReceiver, ArrayList&lt;ReceiverRecord&gt;&gt; mReceivers = new HashMap&lt;&gt;();// 映射： 操作（行为） -&gt; 接收器记录的列表private final HashMap&lt;String, ArrayList&lt;ReceiverRecord&gt;&gt; mActions = new HashMap&lt;&gt;();// 保存了广播记录的列表，即将被广播private final ArrayList&lt;BroadcastRecord&gt; mPendingBroadcasts = new ArrayList&lt;&gt;(); 注册广播123456789101112131415161718192021222324252627282930/** * Register a receive for any local broadcasts that match the given IntentFilter. * 根据给定的 IntentFilter，注册本地广播。 * * @param receiver The BroadcastReceiver to handle the broadcast. * @param filter Selects the Intent broadcasts to be received. * * @see #unregisterReceiver */public void registerReceiver(@NonNull BroadcastReceiver receiver, @NonNull IntentFilter filter) &#123; synchronized (mReceivers) &#123; ReceiverRecord entry = new ReceiverRecord(filter, receiver); ArrayList&lt;ReceiverRecord&gt; filters = mReceivers.get(receiver); if (filters == null) &#123; filters = new ArrayList&lt;&gt;(1); mReceivers.put(receiver, filters); &#125; filters.add(entry); for (int i = 0; i &lt; filter.countActions(); i++) &#123; String action = filter.getAction(i); ArrayList&lt;ReceiverRecord&gt; entries = mActions.get(action); if (entries == null) &#123; entries = new ArrayList&lt;ReceiverRecord&gt;(1); mActions.put(action, entries); &#125; entries.add(entry); &#125; &#125;&#125; 反注册广播1234567891011121314151617181920212223242526272829303132333435363738/** * Unregister a previously registered BroadcastReceiver. &lt;em&gt;All&lt;/em&gt; * filters that have been registered for this BroadcastReceiver will be * removed. * 反注册之前注册的广播接收器。所有与该广播接收器有关的、已被注册的过滤器也将会被移除。 * * @param receiver The BroadcastReceiver to unregister. * * @see #registerReceiver */public void unregisterReceiver(@NonNull BroadcastReceiver receiver) &#123; synchronized (mReceivers) &#123; final ArrayList&lt;ReceiverRecord&gt; filters = mReceivers.remove(receiver); if (filters == null) &#123; return; &#125; for (int i = filters.size() - 1; i &gt;= 0; i--) &#123; final ReceiverRecord filter = filters.get(i); filter.dead = true; for (int j = 0; j &lt; filter.filter.countActions(); j++) &#123; final String action = filter.filter.getAction(j); final ArrayList&lt;ReceiverRecord&gt; receivers = mActions.get(action); if (receivers != null) &#123; for (int k = receivers.size() - 1; k&gt;=0; k--) &#123; final ReceiverRecord rec = receivers.get(k); if (rec.receiver == receiver) &#123; rec.dead = true; receivers.remove(k); &#125; &#125; if (receivers.size() &lt;= 0) &#123; mActions.remove(action); &#125; &#125; &#125; &#125;. &#125;&#125; 发送广播（异步方法），代码比较长，已省略日志相关代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * Broadcast the given intent to all interested BroadcastReceivers. This * call is asynchronous; it returns immediately, and you will continue * executing while the receivers are run. * 把给定的 intent 对象广播给所有对其感兴趣的广播接收器。这个方法的调用是异步的， * 它会马上返回，在接收器运行的时候，你能够继续执行其他操作。 * * @param intent The Intent to broadcast; all receivers matching this * Intent will receive the broadcast. * * @see #registerReceiver * * @return Returns true if the intent has been scheduled for delivery to one or more * broadcast receivers. (Note tha delivery may not ultimately take place if one of those * receivers is unregistered before it is dispatched.) * 如果该 intent 对象已被安排传递给一个或多个广播接收器，则返回true。 * （请注意，如果其中一个接收器在发送之前未注册，则最终可能不会发送。） */public boolean sendBroadcast(@NonNull Intent intent) &#123; synchronized (mReceivers) &#123; final String action = intent.getAction(); final String type = intent.resolveTypeIfNeeded( mAppContext.getContentResolver()); final Uri data = intent.getData(); final String scheme = intent.getScheme(); final Set&lt;String&gt; categories = intent.getCategories(); ArrayList&lt;ReceiverRecord&gt; entries = mActions.get(intent.getAction()); if (entries != null) &#123; ArrayList&lt;ReceiverRecord&gt; receivers = null; for (int i=0; i&lt;entries.size(); i++) &#123; ReceiverRecord receiver = entries.get(i); if (receiver.broadcasting) &#123; // 该 receiver 已经被添加过了 // 从下面的代码可以看出，添加过之后 receiver.broadcasting 会设为 true continue; &#125; int match = receiver.filter.match(action, type, scheme, data, categories, \"LocalBroadcastManager\"); if (match &gt;= 0) &#123; if (receivers == null) &#123; receivers = new ArrayList&lt;ReceiverRecord&gt;(); &#125; receivers.add(receiver); receiver.broadcasting = true; &#125; else &#123; // 省略，打印匹配失败原因的日志 &#125; &#125; if (receivers != null) &#123; for (int i=0; i&lt;receivers.size(); i++) &#123; receivers.get(i).broadcasting = false; &#125; mPendingBroadcasts.add(new BroadcastRecord(intent, receivers)); /* 当 mHandler 对象关联的消息队列中没有包含 what 字段为 MSG_EXEC_PENDING_BROADCASTS 消息时,发送该消息，交给 mHandler 处理， 他会执行 executePendingBroadcasts() 方法； 否则，由于 executePendingBroadcasts() 方法还未退出循环，无需再次执行。 */ if (!mHandler.hasMessages(MSG_EXEC_PENDING_BROADCASTS)) &#123; mHandler.sendEmptyMessage(MSG_EXEC_PENDING_BROADCASTS); &#125; return true; &#125; &#125; &#125; return false;&#125; 看一下构造方法中 Handler 的定义12345678910111213mHandler = new Handler(context.getMainLooper()) &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_EXEC_PENDING_BROADCASTS: executePendingBroadcasts(); break; default: super.handleMessage(msg); &#125; &#125;&#125;; 发送广播（同步方法）12345678910111213/** * Like &#123;@link #sendBroadcast(Intent)&#125;, but if there are any receivers for * the Intent this function will block and immediately dispatch them before * returning. * 跟 sendBroadcast(Intent) 类似，但当存在接收该 intent 的接收器，该方法将会阻塞， * 并且在方法返回前，立即派遣这些广播。 */public void sendBroadcastSync(@NonNull Intent intent) &#123; if (sendBroadcast(intent)) &#123; // 执行等待发送的广播，具体看下面 executePendingBroadcasts(); &#125;&#125; 执行等待处理的广播12345678910111213141516171819202122232425262728293031private void executePendingBroadcasts() &#123; while (true) &#123; final BroadcastRecord[] brs; synchronized (mReceivers) &#123; final int N = mPendingBroadcasts.size(); /* 当没有需要发送的广播时，退出循环。 前面当消息队列中仍有 MSG_EXEC_PENDING_BROADCASTS 消息时， 表示该循环还未退出，但可以继续往 mPendingBroadcasts 列表里添加广播； 再次检查该列表的大小，发现有新的广播时，则可以继续执行，将广播分配给它的接收器。 */ if (N &lt;= 0) &#123; return; &#125; brs = new BroadcastRecord[N]; mPendingBroadcasts.toArray(brs); mPendingBroadcasts.clear(); &#125; for (int i = 0; i &lt; brs.length; i++) &#123; final BroadcastRecord br = brs[i]; final int nbr = br.receivers.size(); for (int j = 0; j &lt; nbr; j++) &#123; final ReceiverRecord rec = br.receivers.get(j); if (!rec.dead) &#123; rec.receiver.onReceive(mAppContext, br.intent); &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"笔记","slug":"笔记","permalink":"https://v3887023.github.io/categories/笔记/"}],"tags":[{"name":"源码","slug":"源码","permalink":"https://v3887023.github.io/tags/源码/"},{"name":"Android","slug":"Android","permalink":"https://v3887023.github.io/tags/Android/"}]},{"title":"对 DAO 的误解和一些认识","slug":"对-DAO-的误解和一些认识","date":"2018-10-08T12:55:29.000Z","updated":"2018-10-08T12:57:17.690Z","comments":true,"path":"2018/10/08/对-DAO-的误解和一些认识/","link":"","permalink":"https://v3887023.github.io/2018/10/08/对-DAO-的误解和一些认识/","excerpt":"一直以来把 DAO 理解错了 orz","text":"一直以来把 DAO 理解错了 orz ​ 之前，有了解到 DAO 这个词，知道他是 Data Access Object，数据库访问对象，以为就是我之前写的XxxManager，所以，当要使用数据库的时候，就直接把细节全写在一个类里面。 ​ 直到今天，在看了谷歌给的 Android Architecture 时，觉得他的用法很奇怪。于是再次查了一下百度和维基百科，发现我之前没有看仔细，也想错了。 DAO (Data Access Object) 是一个数据访问接口，数据访问：顾名思义就是与数据库打交道。夹在业务逻辑与数据库资源中间 –摘自百度百科 In computer software, a data access object (DAO) is an object that provides an abstract interface to some type of database or other persistence mechanism. By mapping application calls to the persistence layer, the DAO provides some specific data operations without exposing details of the database. –摘自维基百科 ​ 其实就是把对数据库的一系列操作给抽出来，写成一个接口，隐藏了操作数据库的细节，以实现封装的效果。这样，当更换数据库或者测试时也能够很方便。 ​ 所以说，学习的时候还是要认真一点，不然会走歪路。还好跟紧 Google 老大的步伐，否则，可能还会一直错下去呢。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://v3887023.github.io/categories/笔记/"}],"tags":[{"name":"DAO","slug":"DAO","permalink":"https://v3887023.github.io/tags/DAO/"},{"name":"数据库","slug":"数据库","permalink":"https://v3887023.github.io/tags/数据库/"}]},{"title":"暑假总结","slug":"暑假总结","date":"2018-09-27T11:44:25.000Z","updated":"2018-09-27T11:49:47.378Z","comments":true,"path":"2018/09/27/暑假总结/","link":"","permalink":"https://v3887023.github.io/2018/09/27/暑假总结/","excerpt":"这个本来应该是在暑假结束之际做的，也在接近8月底的时候在滴答清单里面添加了这个任务，但还是一直拖到了现在，我也是佩服自己了。虽说如此，但是我自己也是有经常在回想暑假做过的事情。","text":"这个本来应该是在暑假结束之际做的，也在接近8月底的时候在滴答清单里面添加了这个任务，但还是一直拖到了现在，我也是佩服自己了。虽说如此，但是我自己也是有经常在回想暑假做过的事情。 重构了监控器的App，其中，个人最满意的一点，就是图片的加载优化了。图片加载摸索了很久，终于算是想出来一个相对较好的加载方式。其他的基本上是在师兄代码的基础上进行一些布局的修改和逻辑的优化。代码基本上都是自己打出来的，也一直维护优化到现在，打算最近添加注释，再把细节方面优化一下，就要收工了。 张鑫中师兄提供了一次做项目的机会。虽然项目很简单，但是我还是学到了不少东西。比如，这是一次我做得最快的一次小项目；在项目中使用了蓝牙以及实现了同步等一些我之前一直想做的一些功能。其他的就是一些很基本的操作，界面也相对简单。不过其中让我最不爽的就是跟后台对接了。 花了几天的时间，学习了RxJava。通过博客、视频、代码等多种方式，基本上对它有了一些认识，不像刚开始看得很懵。不过，就是没有实际在项目中使用过，唉，一直没机会。 大致了解了Kotlin的语法，虽然现在忘得快差不多了。不过，对于长时间接触Java的我来说，这门语言还是能给我带来很多的乐趣的。 学习了一部分自定义View，跟着教程，学习了Canvas画图，不过，可惜，后面因为要中途去做师兄的项目，就搁下了，到现在一直没动过，可能短时间内也不会碰了。 回家时，花了两天时间，重构了寒假时写的天气预报。完成后，总体感觉很不错，至少，在这半年多的时间里，我有了许多的进步。 学习了Material Design，大致了解了MD的一些基本的要求 看完《织梦人》这本书，花了半年。。。没办法，一直拖。不过书的内容还是很有趣，跟当时看《苏菲的世界》差不多。（唉，读后感想不出来） 因为鑫中师兄的关系，我开始考虑考研，但后面一直摇摆不定，总因为这样那样的原因，动摇了，知道现在，我应该是暂时不想考研，这段时间，先好好学习，准备面试，考研的事情，等老哥考完之后再做打算。 由于写这个总结拖得有点久，而且这段时间我的心里也很乱，所以，很多写的有点乱，不过，还是当成暑假的总结来写，一些有冲突的就不写了。","categories":[{"name":"私人","slug":"私人","permalink":"https://v3887023.github.io/categories/私人/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://v3887023.github.io/tags/随笔/"}]},{"title":"今日随笔","slug":"今日随笔","date":"2018-07-31T13:59:45.000Z","updated":"2018-08-31T03:23:38.087Z","comments":true,"path":"2018/07/31/今日随笔/","link":"","permalink":"https://v3887023.github.io/2018/07/31/今日随笔/","excerpt":"一些感想","text":"一些感想 ​ 今天，可能是比较闲的缘故，开始胡思乱想，不过主要还是关于以后的学习和工作的。 ​ 从开始学习 Android 到现在，也已经有一年多的时间了。想想当初从网页前端转去学习 Android，其中的原因，大部分是 Android 会相对容易一些，至少我当时是那么觉得的。当然，这其中也有着比较艰难的选择历程，最后，我还是选择了走这条路。 ​ 之后，一个表哥问我，有没有去关注 Android 就业形势。我说没有，然后开始去找一些招聘启事，觉得还行。而且我对 Android 的兴趣还是很浓厚的，所以没有怎么动摇。但今天，当我再次问自己这个问题时，我发现，我开始不能那么确定走这条路了，而且还开始考虑考研了。毕竟，我的水平还不够，靠 Android 吃饭我还不是很敢想。 ​ 随着做的小项目的增多，我越来越发现，写的代码很多都是差不多的，但是相对来说我做的不是很流畅，越发觉得那些 Android 开发者好厉害。比如说，我一直很看不起的 RAM 不到 1 GB 的 只是 Android 4.4.4 的华为手机，竟然能够很流畅的运行 ”跳舞的线” 这款游戏，这真的出乎我意料。想想，我目前的技术水平真的不值一提，唉。 ​ 我之前一直比较坚持不想考研，原因很多，这里也不多说。但想想，这件事还是不能草率的做决定，真的要考虑到自己的未来发展，不能囿于自己目前的狭隘视野。后面，在学业上还是要继续努力，在技术上多下功夫，大三这一年，会比前面两年更加苦更加累，要坚持，坚定自己的信念，走下去。 ​ 想的事情比较多，比较乱，所以写的也很乱，不过没事，这也有待提高。继续加油吧！","categories":[{"name":"私人","slug":"私人","permalink":"https://v3887023.github.io/categories/私人/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://v3887023.github.io/tags/随笔/"}]},{"title":"位运算笔记整理","slug":"位运算笔记整理","date":"2018-01-18T05:17:41.000Z","updated":"2018-06-16T12:57:17.876Z","comments":true,"path":"2018/01/18/位运算笔记整理/","link":"","permalink":"https://v3887023.github.io/2018/01/18/位运算笔记整理/","excerpt":"整理了一些位运算的用法。","text":"整理了一些位运算的用法。 根据末尾数字判定 num 的奇偶 1num &amp; 1 把 num 最末位的数字强行变成 1 1num | 1 ​ 把 num 最末位数字强行变成 0 1num | 1 - 1 ​ 两次异或同一个数，最后的结果不变，可用于简单的加密 ​ 实现 a 和 b 两个数交换 123a = a + bb = a - ba = a - b 123a = a | bb = a | ba = a | b ​ 计算机系统中，数值一律用补码来表示和存储 ​ 补码和原码的相互转换的运算过程相同 ​ 一个负整数（或原码）与其补数（或补码）相加，和为模 ​ 对一个数的补码再求补码，等于它本身 ​ 补码的正零与负零的表示方法相同 ​ a &lt;&lt; b 相当于 $ a \\, * \\, 2^b $ a &gt;&gt; b 相当于 $ a \\, / \\, 2 ^ b $ （结果取整）","categories":[{"name":"笔记","slug":"笔记","permalink":"https://v3887023.github.io/categories/笔记/"}],"tags":[{"name":"位运算","slug":"位运算","permalink":"https://v3887023.github.io/tags/位运算/"}]},{"title":"Hexo + GitHub 搭建个人博客","slug":"Hexo-GitHub-搭建个人博客","date":"2018-01-10T16:16:58.000Z","updated":"2018-06-16T12:56:14.003Z","comments":true,"path":"2018/01/11/Hexo-GitHub-搭建个人博客/","link":"","permalink":"https://v3887023.github.io/2018/01/11/Hexo-GitHub-搭建个人博客/","excerpt":"这一篇记录了我搭建个人博客的过程，参考并整理多个博客的内容，结合自己的经验，把过程陈述如下。","text":"这一篇记录了我搭建个人博客的过程，参考并整理多个博客的内容，结合自己的经验，把过程陈述如下。 准备拥有一个 GitHub 账户，如果没有的话请移步 GitHub官网 注册。 然后新建一个仓库 New repository ，仓库名为 你的用户名.github.io （”你的用户名”即为你自己的 GitHub 用户名，比如我的用户名为 v3887023 ，则我的仓库名命名为 v3887023.github.io ）。 安装 Node.js 安装 Git 安装 Hexo打开 CMD ，输入下面代码即可安装 Hexo 1npm install -g hexo-cli ​ 然后，选定好博客框架的放置目录，输入下面代码即可初始化框架 123hexo init &lt;yourFolder&gt;cd &lt;yourFolder&gt;npm install 注意：&lt;yourFolder&gt; 即为你的博客的目录，使用上面的代码初始化时，该目录如果存在，则会出错，如果不存在，则会新建一个目录，然后进行一系列的初始化操作。 ​ 初始化后的目录大致是这样的：（如下图） 文件目录概况 其中， source\\_posts 文件夹里面会自动生成一个 hello-world.md 文件， themes 文件夹中有默认的主题 landscape 。 ​ 输入 hexo server 或 hexo s ，完成后在浏览器输入 http://localhost:4000/ 即可看到带有默认主题的默认网页了。不过，到目前为止，它只能在本地查看，可以把它当作发布前的预览。 打开网页后大概是这样的： 网页样例 ​ 默认主题说实话真不好看，我选择的是 nexT 主题。GitHub 上面也有其他主题可供选择。 在博客的根目录输入下面代码，会自动下载主题到 themes 目录 1git clone https://github.com/iissnan/hexo-theme-next themes/next ​ 主题下载完成后，打开博客根目录的配置文件 _config.yml ，把 Extension 那一项的 theme 属性改为 next 即可，如下： 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next 注意：属性和值之间要空一格，属性前面不能有空格，否则会出错（个人经验，有错的话请提出） ​ 还是在配置文件中，把 Deployment 那一项的 deploy 属性做一下填写，就可以将博客的网页上传到 GitHub 了。 代码如下： 123456# Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: 你的 GitHub 仓库地址(比如我的是 https://github.com/v3887023/v3887023.github.io.git) branch: master ​ 仓库地址（HTTPS 或 SSH）可以通过仓库里面的 Clone or download 按钮获he得，如图： GitHub仓库地址 ​ 输入 hexo g 或 hexo generate 生成网站的静态文件，完成后会看到根目录多出了一个 public 文件夹。 开始部署前，先输入以下代码，安装部署网站需要的插件： 1npm install hexo-deployer-git --save ​ 然后输入 hexo deploy 或 hexo d 部署网页，Hexo 会自动把 public 文件夹里面的文件推到 GitHub 上面。这样一来，就成功把网页部署在 GitHub 上面了，此时，可以通过访问 https://你的仓库名/ （比如我的 https:/v3887023.github.io/ ）看到 Hexo 自动生成的 hello-world.md 在你的博客上面的展示了。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://v3887023.github.io/categories/笔记/"}],"tags":[{"name":"搭建博客","slug":"搭建博客","permalink":"https://v3887023.github.io/tags/搭建博客/"},{"name":"Hexo","slug":"Hexo","permalink":"https://v3887023.github.io/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://v3887023.github.io/tags/GitHub/"}]}]}