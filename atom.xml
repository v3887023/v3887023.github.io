<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>See!</title>
  
  <subtitle>What can I do.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://v3887023.github.io/"/>
  <updated>2019-06-15T09:36:51.339Z</updated>
  <id>https://v3887023.github.io/</id>
  
  <author>
    <name>Victor</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>String 类</title>
    <link href="https://v3887023.github.io/2019/06/15/String-%E7%B1%BB/"/>
    <id>https://v3887023.github.io/2019/06/15/String-类/</id>
    <published>2019-06-15T09:33:59.000Z</published>
    <updated>2019-06-15T09:36:51.339Z</updated>
    
    <content type="html"><![CDATA[<hr><p>记录关于 String 类的一些笔记。</p><a id="more"></a><hr><p><code>equals</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果是同一个对象，直接返回 true</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断比较的对象是否为 String 类型</span></span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = length();</span><br><span class="line">        <span class="comment">// 判断两个字符串长度是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.length()) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 逐个判断每个字符是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (charAt(i) != anotherString.charAt(i))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源码可以看出，<code>String</code> 类重写了 <code>equals</code> 方法，比较两个 <code>String</code> 对象是否 equals 的方法也很简单，就是看它们是否是同一个对象或者他们的字符串序列完全相同。</p><hr><p><code>hashCode</code> 方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;   <span class="comment">// hash 的值默认为空</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> len = length();</span><br><span class="line">    <span class="comment">// 如果 h 不为 0，即 hash 的值不为 0，说明已经计算过了 </span></span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面的代码可以看到几点：</p><ol><li>空字符串的 hashCode 为 0</li><li>一个 String 对象的 hashCode 计算过一次后会保存在 hash 字段，下次要获取时直接返回</li><li>对于一个字符串 s，它的 hashCode 的计算方法为<br><code>s[0] * 31^(n - 1) + s[1] * 31^(n - 2) + ... + s[n - 1]</code></li></ol><p>尽管如此，还是要注意，由于字符串理论上可以有无数多个，而 int 类型的 hashCode 的取值范围在 [- 2 ^ 31, 2 ^ 31 - 1]，只有 2 ^ 32 （即 4294967296）个数，肯定会发生不同的字符串却有相同的 hashCode 的情况。例如，”Aa” 和 “BB” 这两个字符串的 hashCode 都为 2112。</p><p>对于这里的算法为什么采用 31 作为乘数，网上的说法也是各种各样。这里列一下觉得比较靠谱的说法：</p><ol><li>31是一个不大不小的质数，而且是一个奇数</li><li>31可以被 JVM 优化，31 * i = (i &lt;&lt; 5) - i</li></ol><p>个人的猜想：<br>这样的一个算法，能够让数值均匀而又随机地分布在 hash 变量所占的 32 位空间上，因为每次会左移 5 位然后减掉当前值，这样一来这个 32 位的空间都会利用到，而且，当在需要使用 hashCode 的场景时，如 HashMap 的 hash 方法，会将高 16 位的数值与低 16 位的数值做异或运算，从而降低哈希碰撞的概率。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;记录关于 String 类的一些笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://v3887023.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="String" scheme="https://v3887023.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>LocalBroadcastManager 笔记</title>
    <link href="https://v3887023.github.io/2019/06/03/LocalBroadcastManager-%E7%AC%94%E8%AE%B0/"/>
    <id>https://v3887023.github.io/2019/06/03/LocalBroadcastManager-笔记/</id>
    <published>2019-06-03T08:59:13.000Z</published>
    <updated>2019-06-03T09:53:42.510Z</updated>
    
    <content type="html"><![CDATA[<hr><p>记录学习 LocalBroadcastManager 的过程。</p><a id="more"></a><hr><p><code>LocalBroadcastManager</code> 是一个帮助注册和发送广播的一个管理类。它能够在进程内发送包含 <code>Intent</code> 对象的广播。比起发送全局广播，它有以下几个有点：</p><ol><li>广播的数据不会离开当前的 App，因此无需担心会泄漏隐私数据</li><li>其他应用程序无法向当前的 App 发送广播，因此也无需担心他们会利用安全漏洞搞事情</li><li>比起发送一个全局广播遍布整个系统，本地广播更加高效。</li></ol><p><code>LocalBroadcastManager</code> 有两个私有静态内部类，即 <code>ReceiverRecord</code> 和 <code>BraodcastRecord</code>。</p><p><code>ReceiverRecord</code> 是接收器的记录。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiverRecord</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> IntentFilter filter;</span><br><span class="line">    <span class="keyword">final</span> BroadcastReceiver receiver;</span><br><span class="line">    <span class="keyword">boolean</span> broadcasting;</span><br><span class="line">    <span class="keyword">boolean</span> dead;</span><br><span class="line"></span><br><span class="line">    ReceiverRecord(IntentFilter _filter, BroadcastReceiver _receiver) &#123;</span><br><span class="line">        filter = _filter;</span><br><span class="line">        receiver = _receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ... <span class="comment">//省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>BroadcastRecord</code> 是广播的记录。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BroadcastRecord</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Intent intent;</span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;ReceiverRecord&gt; receivers;</span><br><span class="line"></span><br><span class="line">    BroadcastRecord(Intent _intent, ArrayList&lt;ReceiverRecord&gt; _receivers) &#123;</span><br><span class="line">        intent = _intent;</span><br><span class="line">        receivers = _receivers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>LocalBroadcastManager</code> 采用了单例模式，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Context mAppContext;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_EXEC_PENDING_BROADCASTS = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Handler mHandler;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object mLock = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> LocalBroadcastManager mInstance;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalBroadcastManager <span class="title">getInstance</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mInstance = <span class="keyword">new</span> LocalBroadcastManager(context.getApplicationContext());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">LocalBroadcastManager</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    mAppContext = context;</span><br><span class="line">    mHandler = ...  <span class="comment">// 省略，初始化 Handler，这个后面会提到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>LocalBroadcastManager</code> 的几个重要成员变量，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 映射：广播接收器 -&gt; 接收器记录的列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;BroadcastReceiver, ArrayList&lt;ReceiverRecord&gt;&gt; mReceivers</span><br><span class="line">        = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 映射： 操作（行为） -&gt; 接收器记录的列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, ArrayList&lt;ReceiverRecord&gt;&gt; mActions = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存了广播记录的列表，即将被广播</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;BroadcastRecord&gt; mPendingBroadcasts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure></p><p>注册广播<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register a receive for any local broadcasts that match the given IntentFilter.</span></span><br><span class="line"><span class="comment"> * 根据给定的 IntentFilter，注册本地广播。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> receiver The BroadcastReceiver to handle the broadcast.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filter Selects the Intent broadcasts to be received.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #unregisterReceiver</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerReceiver</span><span class="params">(@NonNull BroadcastReceiver receiver,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull IntentFilter filter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mReceivers) &#123;</span><br><span class="line">        ReceiverRecord entry = <span class="keyword">new</span> ReceiverRecord(filter, receiver);</span><br><span class="line">        ArrayList&lt;ReceiverRecord&gt; filters = mReceivers.get(receiver);</span><br><span class="line">        <span class="keyword">if</span> (filters == <span class="keyword">null</span>) &#123;</span><br><span class="line">            filters = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">            mReceivers.put(receiver, filters);</span><br><span class="line">        &#125;</span><br><span class="line">        filters.add(entry);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; filter.countActions(); i++) &#123;</span><br><span class="line">            String action = filter.getAction(i);</span><br><span class="line">            ArrayList&lt;ReceiverRecord&gt; entries = mActions.get(action);</span><br><span class="line">            <span class="keyword">if</span> (entries == <span class="keyword">null</span>) &#123;</span><br><span class="line">                entries = <span class="keyword">new</span> ArrayList&lt;ReceiverRecord&gt;(<span class="number">1</span>);</span><br><span class="line">                mActions.put(action, entries);</span><br><span class="line">            &#125;</span><br><span class="line">            entries.add(entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>反注册广播<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Unregister a previously registered BroadcastReceiver.  &lt;em&gt;All&lt;/em&gt;</span></span><br><span class="line"><span class="comment"> * filters that have been registered for this BroadcastReceiver will be</span></span><br><span class="line"><span class="comment"> * removed.</span></span><br><span class="line"><span class="comment"> * 反注册之前注册的广播接收器。所有与该广播接收器有关的、已被注册的过滤器也将会被移除。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> receiver The BroadcastReceiver to unregister.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #registerReceiver</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterReceiver</span><span class="params">(@NonNull BroadcastReceiver receiver)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mReceivers) &#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;ReceiverRecord&gt; filters = mReceivers.remove(receiver);</span><br><span class="line">        <span class="keyword">if</span> (filters == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = filters.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReceiverRecord filter = filters.get(i);</span><br><span class="line">            filter.dead = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; filter.filter.countActions(); j++) &#123;</span><br><span class="line">                <span class="keyword">final</span> String action = filter.filter.getAction(j);</span><br><span class="line">                <span class="keyword">final</span> ArrayList&lt;ReceiverRecord&gt; receivers = mActions.get(action);</span><br><span class="line">                <span class="keyword">if</span> (receivers != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = receivers.size() - <span class="number">1</span>; k&gt;=<span class="number">0</span>; k--) &#123;</span><br><span class="line">                        <span class="keyword">final</span> ReceiverRecord rec = receivers.get(k);</span><br><span class="line">                        <span class="keyword">if</span> (rec.receiver == receiver) &#123;</span><br><span class="line">                            rec.dead = <span class="keyword">true</span>;</span><br><span class="line">                            receivers.remove(k);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (receivers.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        mActions.remove(action);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>发送广播（异步方法），代码比较长，已省略日志相关代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Broadcast the given intent to all interested BroadcastReceivers.  This</span></span><br><span class="line"><span class="comment"> * call is asynchronous; it returns immediately, and you will continue</span></span><br><span class="line"><span class="comment"> * executing while the receivers are run.</span></span><br><span class="line"><span class="comment"> * 把给定的 intent 对象广播给所有对其感兴趣的广播接收器。这个方法的调用是异步的，</span></span><br><span class="line"><span class="comment"> * 它会马上返回，在接收器运行的时候，你能够继续执行其他操作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> intent The Intent to broadcast; all receivers matching this</span></span><br><span class="line"><span class="comment"> *     Intent will receive the broadcast.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #registerReceiver</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Returns true if the intent has been scheduled for delivery to one or more</span></span><br><span class="line"><span class="comment"> * broadcast receivers.  (Note tha delivery may not ultimately take place if one of those</span></span><br><span class="line"><span class="comment"> * receivers is unregistered before it is dispatched.)</span></span><br><span class="line"><span class="comment"> * 如果该 intent 对象已被安排传递给一个或多个广播接收器，则返回true。</span></span><br><span class="line"><span class="comment"> * （请注意，如果其中一个接收器在发送之前未注册，则最终可能不会发送。）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendBroadcast</span><span class="params">(@NonNull Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mReceivers) &#123;</span><br><span class="line">        <span class="keyword">final</span> String action = intent.getAction();</span><br><span class="line">        <span class="keyword">final</span> String type = intent.resolveTypeIfNeeded(</span><br><span class="line">                mAppContext.getContentResolver());</span><br><span class="line">        <span class="keyword">final</span> Uri data = intent.getData();</span><br><span class="line">        <span class="keyword">final</span> String scheme = intent.getScheme();</span><br><span class="line">        <span class="keyword">final</span> Set&lt;String&gt; categories = intent.getCategories();</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;ReceiverRecord&gt; entries = mActions.get(intent.getAction());</span><br><span class="line">        <span class="keyword">if</span> (entries != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ArrayList&lt;ReceiverRecord&gt; receivers = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;entries.size(); i++) &#123;</span><br><span class="line">                ReceiverRecord receiver = entries.get(i);</span><br><span class="line">                <span class="keyword">if</span> (receiver.broadcasting) &#123;</span><br><span class="line">                    <span class="comment">// 该 receiver 已经被添加过了</span></span><br><span class="line">                    <span class="comment">// 从下面的代码可以看出，添加过之后 receiver.broadcasting 会设为 true</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> match = receiver.filter.match(action, type, scheme, data,</span><br><span class="line">                        categories, <span class="string">"LocalBroadcastManager"</span>);</span><br><span class="line">                <span class="keyword">if</span> (match &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (receivers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        receivers = <span class="keyword">new</span> ArrayList&lt;ReceiverRecord&gt;();</span><br><span class="line">                    &#125;</span><br><span class="line">                    receivers.add(receiver);</span><br><span class="line">                    receiver.broadcasting = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 省略，打印匹配失败原因的日志</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (receivers != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;receivers.size(); i++) &#123;</span><br><span class="line">                    receivers.get(i).broadcasting = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                mPendingBroadcasts.add(<span class="keyword">new</span> BroadcastRecord(intent, receivers));</span><br><span class="line">                <span class="comment">/* </span></span><br><span class="line"><span class="comment">                    当 mHandler 对象关联的消息队列中没有包含 what 字段为</span></span><br><span class="line"><span class="comment">                    MSG_EXEC_PENDING_BROADCASTS 消息时,发送该消息，交给 mHandler 处理，</span></span><br><span class="line"><span class="comment">                    他会执行 executePendingBroadcasts() 方法；</span></span><br><span class="line"><span class="comment">                    否则，由于 executePendingBroadcasts() 方法还未退出循环，无需再次执行。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (!mHandler.hasMessages(MSG_EXEC_PENDING_BROADCASTS)) &#123;</span><br><span class="line">                    mHandler.sendEmptyMessage(MSG_EXEC_PENDING_BROADCASTS);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看一下构造方法中 Handler 的定义<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mHandler = <span class="keyword">new</span> Handler(context.getMainLooper()) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> MSG_EXEC_PENDING_BROADCASTS:</span><br><span class="line">                executePendingBroadcasts();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>发送广播（同步方法）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Like &#123;<span class="doctag">@link</span> #sendBroadcast(Intent)&#125;, but if there are any receivers for</span></span><br><span class="line"><span class="comment"> * the Intent this function will block and immediately dispatch them before</span></span><br><span class="line"><span class="comment"> * returning.</span></span><br><span class="line"><span class="comment"> * 跟 sendBroadcast(Intent) 类似，但当存在接收该 intent 的接收器，该方法将会阻塞，</span></span><br><span class="line"><span class="comment"> * 并且在方法返回前，立即派遣这些广播。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendBroadcastSync</span><span class="params">(@NonNull Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sendBroadcast(intent)) &#123;</span><br><span class="line">        <span class="comment">// 执行等待发送的广播，具体看下面</span></span><br><span class="line">        executePendingBroadcasts();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行等待处理的广播<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executePendingBroadcasts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> BroadcastRecord[] brs;</span><br><span class="line">        <span class="keyword">synchronized</span> (mReceivers) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> N = mPendingBroadcasts.size();</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                当没有需要发送的广播时，退出循环。</span></span><br><span class="line"><span class="comment">                </span></span><br><span class="line"><span class="comment">                前面当消息队列中仍有 MSG_EXEC_PENDING_BROADCASTS 消息时，</span></span><br><span class="line"><span class="comment">                表示该循环还未退出，但可以继续往 mPendingBroadcasts 列表里添加广播；</span></span><br><span class="line"><span class="comment">                再次检查该列表的大小，发现有新的广播时，则可以继续执行，将广播分配给它的接收器。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (N &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            brs = <span class="keyword">new</span> BroadcastRecord[N];</span><br><span class="line">            mPendingBroadcasts.toArray(brs);</span><br><span class="line">            mPendingBroadcasts.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; brs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> BroadcastRecord br = brs[i];</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> nbr = br.receivers.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nbr; j++) &#123;</span><br><span class="line">                <span class="keyword">final</span> ReceiverRecord rec = br.receivers.get(j);</span><br><span class="line">                <span class="keyword">if</span> (!rec.dead) &#123;</span><br><span class="line">                    rec.receiver.onReceive(mAppContext, br.intent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;记录学习 LocalBroadcastManager 的过程。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://v3887023.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="源码" scheme="https://v3887023.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="Android" scheme="https://v3887023.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>对 DAO 的误解和一些认识</title>
    <link href="https://v3887023.github.io/2018/10/08/%E5%AF%B9-DAO-%E7%9A%84%E8%AF%AF%E8%A7%A3%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%A4%E8%AF%86/"/>
    <id>https://v3887023.github.io/2018/10/08/对-DAO-的误解和一些认识/</id>
    <published>2018-10-08T12:55:29.000Z</published>
    <updated>2018-10-08T12:57:17.690Z</updated>
    
    <content type="html"><![CDATA[<hr><p>一直以来把 DAO 理解错了 orz</p><a id="more"></a><hr><p>​    之前，有了解到 DAO 这个词，知道他是 Data Access Object，数据库访问对象，以为就是我之前写的XxxManager，所以，当要使用数据库的时候，就直接把细节全写在一个类里面。</p><p>​    直到今天，在看了谷歌给的 Android Architecture 时，觉得他的用法很奇怪。于是再次查了一下百度和维基百科，发现我之前没有看仔细，也想错了。</p><blockquote><p>DAO (Data Access Object) 是一个数据访问接口，数据访问：顾名思义就是与数据库打交道。夹在业务逻辑与数据库资源中间</p><p>–摘自百度百科</p><p>In computer software, a data access object (DAO) is an object that provides an abstract interface to some type of database or other persistence mechanism. By mapping application calls to the persistence layer, the DAO provides some specific data operations without exposing details of the database. </p><p>–摘自维基百科</p></blockquote><p>​    其实就是把对数据库的一系列操作给抽出来，写成一个接口，隐藏了操作数据库的细节，以实现封装的效果。这样，当更换数据库或者测试时也能够很方便。</p><p>​    所以说，学习的时候还是要认真一点，不然会走歪路。还好跟紧 Google 老大的步伐，否则，可能还会一直错下去呢。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;一直以来把 DAO 理解错了 orz&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://v3887023.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="DAO" scheme="https://v3887023.github.io/tags/DAO/"/>
    
      <category term="数据库" scheme="https://v3887023.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>暑假总结</title>
    <link href="https://v3887023.github.io/2018/09/27/%E6%9A%91%E5%81%87%E6%80%BB%E7%BB%93/"/>
    <id>https://v3887023.github.io/2018/09/27/暑假总结/</id>
    <published>2018-09-27T11:44:25.000Z</published>
    <updated>2018-09-27T11:49:47.378Z</updated>
    
    <content type="html"><![CDATA[<hr><p>这个本来应该是在暑假结束之际做的，也在接近8月底的时候在滴答清单里面添加了这个任务，但还是一直拖到了现在，我也是佩服自己了。虽说如此，但是我自己也是有经常在回想暑假做过的事情。</p><hr><a id="more"></a><ol><li>重构了监控器的App，其中，个人最满意的一点，就是图片的加载优化了。图片加载摸索了很久，终于算是想出来一个相对较好的加载方式。其他的基本上是在师兄代码的基础上进行一些布局的修改和逻辑的优化。代码基本上都是自己打出来的，也一直维护优化到现在，打算最近添加注释，再把细节方面优化一下，就要收工了。</li><li>张鑫中师兄提供了一次做项目的机会。虽然项目很简单，但是我还是学到了不少东西。比如，这是一次我做得最快的一次小项目；在项目中使用了蓝牙以及实现了同步等一些我之前一直想做的一些功能。其他的就是一些很基本的操作，界面也相对简单。不过其中让我最不爽的就是跟后台对接了。</li><li>花了几天的时间，学习了RxJava。通过博客、视频、代码等多种方式，基本上对它有了一些认识，不像刚开始看得很懵。不过，就是没有实际在项目中使用过，唉，一直没机会。</li><li>大致了解了Kotlin的语法，虽然现在忘得快差不多了。不过，对于长时间接触Java的我来说，这门语言还是能给我带来很多的乐趣的。</li><li>学习了一部分自定义View，跟着教程，学习了Canvas画图，不过，可惜，后面因为要中途去做师兄的项目，就搁下了，到现在一直没动过，可能短时间内也不会碰了。</li><li>回家时，花了两天时间，重构了寒假时写的天气预报。完成后，总体感觉很不错，至少，在这半年多的时间里，我有了许多的进步。</li><li>学习了Material Design，大致了解了MD的一些基本的要求</li><li>看完《织梦人》这本书，花了半年。。。没办法，一直拖。不过书的内容还是很有趣，跟当时看《苏菲的世界》差不多。（唉，读后感想不出来）</li><li>因为鑫中师兄的关系，我开始考虑考研，但后面一直摇摆不定，总因为这样那样的原因，动摇了，知道现在，我应该是暂时不想考研，这段时间，先好好学习，准备面试，考研的事情，等老哥考完之后再做打算。</li></ol><p>由于写这个总结拖得有点久，而且这段时间我的心里也很乱，所以，很多写的有点乱，不过，还是当成暑假的总结来写，一些有冲突的就不写了。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;这个本来应该是在暑假结束之际做的，也在接近8月底的时候在滴答清单里面添加了这个任务，但还是一直拖到了现在，我也是佩服自己了。虽说如此，但是我自己也是有经常在回想暑假做过的事情。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="私人" scheme="https://v3887023.github.io/categories/%E7%A7%81%E4%BA%BA/"/>
    
    
      <category term="随笔" scheme="https://v3887023.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>今日随笔</title>
    <link href="https://v3887023.github.io/2018/07/31/%E4%BB%8A%E6%97%A5%E9%9A%8F%E7%AC%94/"/>
    <id>https://v3887023.github.io/2018/07/31/今日随笔/</id>
    <published>2018-07-31T13:59:45.000Z</published>
    <updated>2018-08-31T03:23:38.087Z</updated>
    
    <content type="html"><![CDATA[<hr><p>一些感想</p><a id="more"></a><hr><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=22636850&auto=0&height=66"></iframe><p>​    今天，可能是比较闲的缘故，开始胡思乱想，不过主要还是关于以后的学习和工作的。</p><p>​    从开始学习 Android 到现在，也已经有一年多的时间了。想想当初从网页前端转去学习 Android，其中的原因，大部分是 Android 会相对容易一些，至少我当时是那么觉得的。当然，这其中也有着比较艰难的选择历程，最后，我还是选择了走这条路。</p><p>​    之后，一个表哥问我，有没有去关注 Android 就业形势。我说没有，然后开始去找一些招聘启事，觉得还行。而且我对 Android 的兴趣还是很浓厚的，所以没有怎么动摇。但今天，当我再次问自己这个问题时，我发现，我开始不能那么确定走这条路了，而且还开始考虑考研了。毕竟，我的水平还不够，靠 Android 吃饭我还不是很敢想。</p><p>​    随着做的小项目的增多，我越来越发现，写的代码很多都是差不多的，但是相对来说我做的不是很流畅，越发觉得那些 Android 开发者好厉害。比如说，我一直很看不起的 RAM 不到 1 GB 的 只是 Android 4.4.4 的华为手机，竟然能够很流畅的运行 ”跳舞的线” 这款游戏，这真的出乎我意料。想想，我目前的技术水平真的不值一提，唉。</p><p>​    我之前一直比较坚持不想考研，原因很多，这里也不多说。但想想，这件事还是不能草率的做决定，真的要考虑到自己的未来发展，不能囿于自己目前的狭隘视野。后面，在学业上还是要继续努力，在技术上多下功夫，大三这一年，会比前面两年更加苦更加累，要坚持，坚定自己的信念，走下去。</p><p>​    想的事情比较多，比较乱，所以写的也很乱，不过没事，这也有待提高。继续加油吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;一些感想&lt;/p&gt;
    
    </summary>
    
      <category term="私人" scheme="https://v3887023.github.io/categories/%E7%A7%81%E4%BA%BA/"/>
    
    
      <category term="随笔" scheme="https://v3887023.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>位运算笔记整理</title>
    <link href="https://v3887023.github.io/2018/01/18/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/"/>
    <id>https://v3887023.github.io/2018/01/18/位运算笔记整理/</id>
    <published>2018-01-18T05:17:41.000Z</published>
    <updated>2018-06-16T12:57:17.876Z</updated>
    
    <content type="html"><![CDATA[<hr><p>整理了一些位运算的用法。</p><a id="more"></a><hr><p>根据末尾数字判定 num 的奇偶</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num &amp; <span class="number">1</span></span><br></pre></td></tr></table></figure><p>把 num 最末位的数字强行变成 1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num | <span class="number">1</span></span><br></pre></td></tr></table></figure><p>​</p><p>把 num 最末位数字强行变成 0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num | <span class="number">1</span> - <span class="number">1</span></span><br></pre></td></tr></table></figure><p>​</p><p>两次异或同一个数，最后的结果不变，可用于简单的加密</p><p>​</p><p>实现 a 和 b 两个数交换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a + b</span><br><span class="line">b = a - b</span><br><span class="line">a = a - b</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a | b</span><br><span class="line">b = a | b</span><br><span class="line">a = a | b</span><br></pre></td></tr></table></figure><p>​</p><p>计算机系统中，数值一律用补码来表示和存储</p><p>​</p><p>补码和原码的相互转换的运算过程相同</p><p>​</p><p>一个负整数（或原码）与其补数（或补码）相加，和为模</p><p>​</p><p>对一个数的补码再求补码，等于它本身</p><p>​</p><p>补码的正零与负零的表示方法相同</p><p>​</p><p><code>a &lt;&lt; b</code> 相当于  $ a \, * \, 2^b $</p><p><code>a &gt;&gt; b</code> 相当于  $ a \, / \, 2 ^ b $ （结果取整）</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;整理了一些位运算的用法。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://v3887023.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="位运算" scheme="https://v3887023.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Hexo + GitHub 搭建个人博客</title>
    <link href="https://v3887023.github.io/2018/01/11/Hexo-GitHub-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://v3887023.github.io/2018/01/11/Hexo-GitHub-搭建个人博客/</id>
    <published>2018-01-10T16:16:58.000Z</published>
    <updated>2018-06-16T12:56:14.003Z</updated>
    
    <content type="html"><![CDATA[<hr><p>这一篇记录了我搭建个人博客的过程，参考并整理多个博客的内容，结合自己的经验，把过程陈述如下。</p><a id="more"></a><hr><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>拥有一个 GitHub 账户，如果没有的话请移步 <a href="https://github.com/" target="_blank" rel="noopener">GitHub官网</a> 注册。</p><p>然后新建一个仓库 <code>New repository</code> ，仓库名为 <code>你的用户名.github.io</code> （”你的用户名”即为你自己的 GitHub 用户名，比如我的用户名为 <code>v3887023</code> ，则我的仓库名命名为 <code>v3887023.github.io</code> ）。</p><p>安装 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a></p><p>安装 <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">Git</a></p><hr><h1 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h1><p>打开 <code>CMD</code> ，输入下面代码即可安装 Hexo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>​</p><p>然后，选定好博客框架的放置目录，输入下面代码即可初始化框架</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;yourFolder&gt;</span><br><span class="line">cd &lt;yourFolder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>&lt;yourFolder&gt;</code> 即为你的博客的目录，使用上面的代码初始化时，该目录如果存在，则会出错，如果不存在，则会新建一个目录，然后进行一系列的初始化操作。</p></blockquote><p>​</p><p>初始化后的目录大致是这样的：（如下图）</p><center><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/pic/folders.png" alt="文件目录概况" title="">                </div>                <div class="image-caption">文件目录概况</div>            </figure></center><blockquote><p>其中， <code>source\_posts</code> 文件夹里面会自动生成一个 <code>hello-world.md</code> 文件， <code>themes</code> 文件夹中有默认的主题 <code>landscape</code> 。</p></blockquote><p>​</p><p>输入 <code>hexo server</code>  或 <code>hexo s</code> ，完成后在浏览器输入 <code>http://localhost:4000/</code> 即可看到带有默认主题的默认网页了。不过，到目前为止，它只能在本地查看，可以把它当作发布前的预览。</p><p>打开网页后大概是这样的：</p><center><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/pic/website.png" alt="网页样例" title="">                </div>                <div class="image-caption">网页样例</div>            </figure></center><p>​</p><p>默认主题说实话真不好看，我选择的是 <code>nexT</code> 主题。GitHub 上面也有其他主题可供选择。</p><p>在博客的根目录输入下面代码，会自动下载主题到 <code>themes</code> 目录 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>​</p><p>主题下载完成后，打开博客根目录的配置文件 <code>_config.yml</code> ，把 <code>Extension</code>  那一项的 <code>theme</code> 属性改为 <code>next</code> 即可，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：属性和值之间要空一格，属性前面不能有空格，否则会出错（个人经验，有错的话请提出）</p></blockquote><p>​</p><p>还是在配置文件中，把 <code>Deployment</code> 那一项的 <code>deploy</code> 属性做一下填写，就可以将博客的网页上传到 GitHub 了。</p><p>代码如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line">   <span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">   deploy:</span></span><br><span class="line"><span class="attr">     type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">     repo:</span> <span class="string">你的</span> <span class="string">GitHub</span> <span class="string">仓库地址(比如我的是</span> <span class="attr">https://github.com/v3887023/v3887023.github.io.git)</span></span><br><span class="line"><span class="attr">     branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>​</p><p>仓库地址（HTTPS 或 SSH）可以通过仓库里面的 <code>Clone or download</code> 按钮获he得，如图：</p><center><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/pic/github_repo_url.png" alt="GitHub仓库地址" title="">                </div>                <div class="image-caption">GitHub仓库地址</div>            </figure></center><p>​</p><p>输入 <code>hexo g</code> 或 <code>hexo generate</code> 生成网站的静态文件，完成后会看到根目录多出了一个 <code>public</code> 文件夹。</p><p>开始部署前，先输入以下代码，安装部署网站需要的插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>​</p><p>然后输入 <code>hexo deploy</code> 或 <code>hexo d</code> 部署网页，Hexo 会自动把 <code>public</code> 文件夹里面的文件推到 GitHub 上面。这样一来，就成功把网页部署在 GitHub 上面了，此时，可以通过访问 <code>https://你的仓库名/</code> （比如我的 <code>https:/v3887023.github.io/</code> ）看到 Hexo 自动生成的 <code>hello-world.md</code> 在你的博客上面的展示了。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;这一篇记录了我搭建个人博客的过程，参考并整理多个博客的内容，结合自己的经验，把过程陈述如下。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://v3887023.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="搭建博客" scheme="https://v3887023.github.io/tags/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="Hexo" scheme="https://v3887023.github.io/tags/Hexo/"/>
    
      <category term="GitHub" scheme="https://v3887023.github.io/tags/GitHub/"/>
    
  </entry>
  
</feed>
